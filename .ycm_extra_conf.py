#!/bin/env python
# Author: Eric Chang
# Date: July 24th, 2018

"""The ycmd configuration script.

This file is used by ycmd to find compilation flags for a file.  It is based on Nils Deppe's file in
2017 and modified on top of that.
"""

import os

import ycm_core

default_flags = ['-x', 'c++', '-Wall', '-Wextra', '-Werror', '-std=c++17']

cpp_source_extensions = {'.cpp', '.cxx', '.cc', '.c', '.m', '.mm'}

header_file_extensions = {'.h', '.H', '.hxx', '.hpp', '.hh'}

completion_database = {}


def FlagsForFile(filename, **_):
    """Returns the flags needed to compile the file.

    Algorithm is as follows:

    1. If no compilation database contains the given file, use default flags.

    2. If flags are found in the compilation database, return them.  Otherwise, reload the database
    and try again.

    3. If flags are still not found, this is probably a source file not added to the build system
    yet, in that case return None so ycmd will try again later.

    Note 1: This function is only called by ycmd if no flags have been loaded for the file. Once
    flags are loaded it is not called again. Or at least that appears to be the behavior.
    
    Note 2: If precompiled headers are not working then the libclang used by ycmd is different than
    the system libclang. The solution seems to be setting ycmd to use the system libclang.

    """
    fdir, fname = os.path.split(filename)
    # check existing database in cache
    ddir, db = next((ddb for ddb in completion_database.items() if ddb[0] in fdir),
                    (None, None))

    if ddir is None:
        # database not in cache, try to find it.
        ddir, db = FindCompilationDatabaseAndDir(fdir, fname)
        if ddir is None:
            # no database found, just return default flags.
            return GetDefaultFlags(fdir)
        # found database, update cache
        completion_database[ddir] = db

    # find compilation info for this file
    compilation_info = GetCompilationInfoForFile(fdir, fname, ddir, db, False)

    if compilation_info is None:
        # cannot find compilation info in database, try updating cache
        db = ycm_core.CompilationDatabase(ddir)
        completion_database[ddir] = db
        # try again after updating cache
        compilation_info = GetCompilationInfoForFile(fdir, fname, ddir, db, True)

    if compilation_info is None:
        # We cannot find compilation info even after refresh.  Since we return default flags for
        # headers, this must be a source file that is not added to build system yet.  Return None to
        # tell YCMD that it should try again later.  try loading the flags again.
        return None

    # return compilation flags
    return {'flags': list(compilation_info.compiler_flags_),
            'include_paths_relative_to_dir':
            compilation_info.compiler_working_dir_}


def FindCompilationDatabaseAndDir(fdir, fname):
    """Find compilation database for the given directory.

    Returns the directory the ycm compilation database was found in, and the database. Returns None
    if no compilation database was found.  This assumes that any compilation database found in the
    hierarchy is the one we want. That is, it assumes projects are not nested.
    """
    while fname:
        if os.path.isfile(os.path.join(fdir, "compile_commands.json")):
            return fdir, ycm_core.CompilationDatabase(fdir)
        fdir, fname = os.path.split(fdir)
    return None


def GetDefaultFlags(fdir):
    """Returns the default compilation flags.
    """
    return {'flags': list(default_flags),
            'include_paths_relative_to_dir': fdir}


def GetCompilationInfoForFile(fdir, fname, ddir, db, use_default_for_header=False):
    """The compilation information from the database.
    
    The compilation_commands.json file generated by CMake does not have entries for header files. So
    we do our best by asking the db for flags for a corresponding source file, if any. If one
    exists, the flags for that file should be good enough.
    """
    basename, ext = os.path.splitext(fname)
    if ext in header_file_extensions:
        comp_info = FindHeaderCompilationInfo(fdir, basename, ddir, db)
        if comp_info is None:
            # source file not found
            return GetDefaultFlags(fdir) if use_default_for_header else None
        else:
            return comp_info
    else:
        return db.GetCompilationInfoForFile(os.path.join(fdir, fname))
    

def FindHeaderCompilationInfo(fdir, basename, ddir, db):
    """Try to find compilation info for a header file.

    Given the basename of a header file, find the compilation info using the following algorithm:

    1. Let HDIR be the header file directory, compute SDIR, which is HDIR with the last occurrence
       of "include" replaced by "src".

    2. Find a source file with the same basename in SDIR.  If it exists, return its compilation
       flags if it has them, otherwise return None.

    3. Otherwise, starting from SDIR, find any source file with compilation flags and return it.
       The search starts from SDIR and ends at the database directory, where we recursively go up,
       and also search for subdirectories we haven't search before.

    4. If all else fails, return None.
    """
    # get source directory
    a, b = fdir.rsplit('include', 1)
    sdir = 'src'.join(a, b)

    # search for source file with matching name
    for sext in cpp_source_extensions:
        cur_fname = os.path.join(sdir, basename + sext)
        if os.path.isfile(cur_fname):
            comp_info = db.GetCompilationInfoForFile(cur_fname)
            return comp_info if comp_info.compiler_flags_ else None

    # search for any source file
    return RecursiveCompilationInfoSearch(sdir, ddir, '', db)


def RecursiveCompilationInfoSearch(cur_dir, stop_dir, exclude_dir, db):
    """Search for any compilation info recursively.

    Find any source file with compilation info in this directory and all subdirectories, excluding
    the given directory name.  If None found, repeat this process in the parent directory, but
    exclude this directory from search (to avoid duplicate search).  This process ends when we reach
    stop_dir.
    """
    # search in this directory and all subdirectories
    test = RecursiveCompilationInfoSearchDown(cur_dir, exclude_dir, db)
    if test is not None:
        return test

    # stop condition
    if cur_dir == stop_dir:
        return None

    # move up
    parent_dir, cur_dir_name = os.path.split(cur_dir)
    return RecursiveCompilationInfoSearch(parent_dir, stop_dir, cur_dir_name, db)


def RecursiveCompilationInfoSearchDown(cur_dir, exclude_dir, db):
    """Search for any compilation info recursively downwards.

    Find any source file with compilation info in current directory.  Recurse in all subdirectories
    if none found.  Skip exclude_dir if it is a subdirectory of the current directory.
    """
    _, sub_dirs, files = next(os.walk(cur_dir))

    # check files in current directory
    for fname in files:
        fbase, fext = os.path.splitext(fname)
        if fext in cpp_source_extensions:
            comp_info = db.GetCompilationInfoForFile(os.path.join(cur_dir, fname))
            if comp_info.compiler_flags_:
                print("Getting flags for a header file, returning compilation flags for file: ",
                      filename)
                return comp_info

    # recurse in all subdirectories
    for next_dir in sub_dirs:
        if next_dir != exclude_dir:
            test = RecursiveCompilationInfoSearchDown(os.path.join(cur_dir, next_dir), '', db)
            if test is not None:
                return test

    return None
